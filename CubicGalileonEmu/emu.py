"""Includes all the emulator functions"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_emu.ipynb.

# %% auto 0
__all__ = ['blockPrint', 'enablePrint', 'emulate', 'load_model_multiple', 'emu_redshift']

# %% ../nbs/03_emu.ipynb 3
from sepia.SepiaModel import SepiaModel
from sepia.SepiaData import SepiaData
from sepia.SepiaPredict import SepiaEmulatorPrediction
# from sepia.SepiaPredict import SepiaFullPrediction
# from sepia.SepiaPredict import SepiaXvalEmulatorPrediction
# from sepia.SepiaSharedThetaModels import SepiaSharedThetaModels
import numpy as np
from .pca import do_pca
from .gp import gp_load
from .load import sepia_data_format
import sys
import os

# %% ../nbs/03_emu.ipynb 5
import os, sys

def blockPrint():
    sys._saved_stdout = sys.stdout
    sys.stdout = open(os.devnull, 'w')

def enablePrint():
    sys.stdout.close()
    sys.stdout = getattr(sys, "_saved_stdout", sys.__stdout__)

# %% ../nbs/03_emu.ipynb 10
def emulate(sepia_model: SepiaModel = None,  # Input model in SEPIA format
                 sepia_data: SepiaData = None,  # Input data in SEPIA format
                 input_params: np.array = None #Input parameter array 
                 ) -> tuple: # 2 np.array of mean and std
    
    if input_params.ndim == 1:
        input_params = np.expand_dims(input_params, 0)

    K = sepia_data.sim_data.K            # shape [r, p] or [p, r] depending on SEPIA; adjust transpose below
    y_sd, y_mean = sepia_data.sim_data.orig_y_sd, sepia_data.sim_data.orig_y_mean

    pred_samples = sepia_model.get_samples(numsamples=1)
    preds = [SepiaEmulatorPrediction(t_pred=param[None, :], samples=pred_samples,
                                     model=sepia_model, storeMuSigma=True)
             for param in input_params]

    means, stds = [], []
    # If K is [p, r], use K_T = K.T; if K is [r, p], use K_T = K
    K_T = K.T  # assumes sepia_data.sim_data.K maps latent -> outputs with y = K^T x

    for pred in preds:
        mu = pred.mu[0]            # shape [r]
        Sigma = pred.sigma[0]      # shape [r, r]

        y_mu = K_T @ mu                            # shape [p]
        y_cov = K_T @ Sigma @ K                    # shape [p, p]
        y_std = np.sqrt(np.clip(np.diag(y_cov), 0, None))

        y_mu = y_sd * y_mu + y_mean
        y_std = y_sd * y_std

        means.append(y_mu)
        stds.append(y_std)

    return np.stack(means, axis=1), np.stack(stds, axis=1)

# %% ../nbs/03_emu.ipynb 12
def load_model_multiple(model_dir:str=None, # Pickle directory path
                        p_train_all:np.array=None, # Parameter array
                        y_vals_all:np.array=None, # Target y-values array
                        y_ind_all:np.array=None, # x-values
                        z_index_range:np.array=None, # Snapshot indices for training
                   ) -> None: 
    
    blockPrint()
    
    model_list = []
    data_list = []
    
    for z_index in z_index_range:
        
        sepia_data = sepia_data_format(p_train_all, y_vals_all[:, z_index, :], y_ind_all)
        
        sepia_model_pca_i = do_pca(sepia_data, exp_variance=0.999)
        
        model_filename = model_dir + 'multivariate_model_z_index' + str(z_index) 
        sepia_model_z = gp_load(sepia_model_pca_i, model_filename)
        model_list.append(sepia_model_z)
        data_list.append(sepia_data)

    enablePrint()

    print('Number of models loaded: ' + str(len(model_list)) + ' from: ' + model_dir  )

    return model_list, data_list
 

# %% ../nbs/03_emu.ipynb 14
def emu_redshift(input_params_and_redshift:np.array=None, # Input parameters (along with redshift) 
                 sepia_model_list:list=None,
                 sepia_data_list:list=None,
                 z_all:np.array=None): # All the trained models
    
    z = input_params_and_redshift[:, -1]
    input_params = input_params_and_redshift[:, :-1]
       
    '''
    if (z == 0):
        # No redshift interpolation for z=0
        GPm, PCAm = model_load(snap_ID=LAST_SNAP, nRankMax=DEFAULT_PCA_RANK)
        Pk_interp = emulate(sepia_model, sepia_data, input_params)
        
        
    else:
    '''
        
    # Linear interpolation between z1 < z < z2
    snap_idx_nearest = (np.abs(z_all - z)).argmin()
    if (z > z_all[snap_idx_nearest]):
        snap_ID_z1 = snap_idx_nearest - 1
        
    else:
        snap_ID_z1 = snap_idx_nearest
    snap_ID_z2 = snap_ID_z1 + 1

    z1 = z_all[snap_ID_z1]
    z2 = z_all[snap_ID_z2]

    # sepia_data_z1 = sepia_data_by_redshift(redshift=z1)
    # sepia_data_z2 = sepia_data_by_redshift(redshift=z2)
    sepia_data_z1 = sepia_data_list[snap_ID_z1]
    sepia_data_z2 = sepia_data_list[snap_ID_z2]
    

    sepia_model_z1 = sepia_model_list[snap_ID_z1]
    Bk_z1, Bk_z1_err = emulate(sepia_model_z1, sepia_data_z1, input_params)
    

    sepia_model_z2 = sepia_model_list[snap_ID_z2]
    Bk_z2, Bk_z2_err = emulate(sepia_model_z2, sepia_data_z2, input_params)

    Bk_interp = np.zeros_like(Bk_z1)
    Bk_interp = Bk_z2 + (Bk_z1 - Bk_z2)*(z - z2)/(z1 - z2)

    Bk_interp_err = np.zeros_like(Bk_z1_err)
    Bk_interp_err = Bk_z2_err + (Bk_z1_err - Bk_z2_err)*(z - z2)/(z1 - z2)
    
    return Bk_interp, Bk_interp_err
